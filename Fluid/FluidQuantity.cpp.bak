#include "FluidQuantity.h"

FluidQuantity::FluidQuantity(Grid<T, d> grid, int faceIndicator)
{

    Phi = new float[grid.counts.Product()];
    Phi_new = new float[grid.counts.Product()];
    this->grid = &grid;

    for (int i = 0; i < d; i++)
    {
        this->faceIndicator = faceIndicator;
    }
}

FluidQuantity::~FluidQuantity() 
{
    delete[] Phi;
    delete[] Phi_new;
}

TV FluidQuantity::computeVelocity(T_INDEX &index, FluidQuantity *FluidVelocity[d])
{
    TV velocity;
    // *Phi + offset(index, (*grid).counts);
    int ix = index[0], iy = index[1], iz = 0;
    if (d == 3)
        iz = index[2];

    // For Scalar
    if (faceIndicator == -1)
    {
        velocity[0] = 0.5 * (FluidVelocity[0]->at_(ix, iy, iz) + FluidVelocity[0]->at_(ix + 1, iy, iz));
        velocity[1] = 0.5 * (FluidVelocity[1]->at_(ix, iy, iz) + FluidVelocity[1]->at_(ix, iy + 1, iz));
        if (d == 3)
            velocity[2] = 0.5 * (FluidVelocity[2]->at_(ix, iy, iz) + FluidVelocity[2]->at_(ix, iy, iz + 1));

        return velocity;
    }

    // For Face Velocity
    for (int i = 0; i < d; i++)
    {
        // Copy value for that exact face
        if (faceIndicator == i)
        {
            velocity[i] = FluidVelocity[i]->at_(ix, iy, iz);
        }
        else
        {
            /* 
            * i: the updating velocity element
            * faceIndicator: the face that this velocity field belongs to
            * rest_index: the index neither i nor faceIndicator. Only valid when d = 3
            */
            Vector<int, 2> v_FI = Vector<int, 2>{0, -1}; // For Face Indicator == 0
            Vector<int, 2> v_UV = Vector<int, 2>{0, 1};  // For The update velocity

            T_INDEX offset_updateV = T_INDEX(0);
            int rest_index;
            double re = 0;

            if (d == 3)
                rest_index = 3 - faceIndicator - i;

            for (int count_fi = 0; count_fi < 2; count_fi++)
            {

                for (int count_uv = 0; count_uv < 2; count_uv++)
                {
                    offset_updateV[faceIndicator] = v_FI[count_fi];
                    offset_updateV[i] = v_UV[count_uv];
                    if (d == 3)
                        offset_updateV[rest_index] = 0;
                }

                re += FluidVelocity[i]->at_(index[0]+offset_updateV[0], index[1]+offset_updateV[1], index[2]+offset_updateV[2]);

                re *= 0.25;
                velocity[i] = re;
            }

            return velocity;
        }
    }
}

void FluidQuantity::advection(double timestep, FluidQuantity *FluidVelocity[d])
{
    

}
